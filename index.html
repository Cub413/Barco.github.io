<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Supervivencia 3D con jugador</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

<style>
body { margin: 0; overflow: hidden; background: #000; }
#joystick { position:absolute; bottom:20px; left:20px; width:100px; height:100px; border-radius:50%; background:rgba(0,0,0,0.3); touch-action:none; }
#stick { width:50px; height:50px; background:rgba(0,0,0,0.5); border-radius:50%; position:absolute; left:25px; top:25px; }
#cameraPanel { position:absolute; bottom:20px; right:20px; width:150px; height:150px; background:rgba(0,0,0,0.25); border-radius:10px; touch-action:none; }
#pauseBtn { position:absolute; top:20px; right:20px; padding:10px 15px; font-size:16px; background:rgba(0,0,0,0.5); color:white; border:none; border-radius:8px; z-index:10; }

#pausePanel {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 9;
  background: rgba(0, 0, 0, 0.7);
  font-family: sans-serif;
}

#pauseContent {
  background: linear-gradient(to bottom, #8B5E3C, #A97457); /* madera clara */
  border: 5px solid #5C3A21; /* borde madera oscura */
  border-radius: 12px;
  padding: 15px;
  max-width: 90%;
  max-height: 80%;
  display: flex;
  flex-direction: column;
  align-items: stretch;
  color: #fff;
  box-shadow: 0 0 20px rgba(0,0,0,0.5);
  overflow: hidden;
}

#pauseContent button {
  background: linear-gradient(to bottom, #C27C4F, #A15B32);
  border: 2px solid #5C3A21;
  border-radius: 8px;
  color: white;
  font-size: 18px;
  padding: 10px;
  margin-bottom: 10px;
  cursor: pointer;
}

#pauseContent button:hover {
  background: linear-gradient(to bottom, #D08F5C, #B26940);
}

#settingsPanel {
  flex: 1;
  overflow: hidden;
  margin-top: 10px;
}

#settingsScroll {
  overflow-y: auto;
  -webkit-overflow-scrolling: touch; /* scroll suave en m√≥viles */
  display: flex;
  flex-direction: column;
  gap: 10px;
  padding-right: 5px;
  max-height: 100%;
}

#settingsScroll label, #settingsScroll fieldset {
  display: flex;
  flex-direction: column;
  font-size: 14px;
  color: #fff;
}

#settingsScroll input[type="range"] {
  margin-top: 5px;
}

#settingsScroll fieldset {
  border: 2px solid #5C3A21;
  border-radius: 8px;
  padding: 10px;
}

#settingsScroll legend {
  padding: 0 5px;
  color: #fff;
  font-weight: bold;
}

#postProcessLabel {
  display: flex;
  align-items: center;
  gap: 5px;
  font-weight: bold;
}
btnPick {
  position: fixed;
  bottom: 20px;
  right: 20px;
  padding: 10px 20px;
  z-index: 10;
}






#panelHorizontal {
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 180, 255, 0.7);
  display: none;
  justify-content: center;
  align-items: center;
  font-size: 2rem;
  color: white;
  cursor: pointer;
  text-align: center;
  z-index: 100001; /* mayor que el bot√≥n */
}

</style>
</head>
<body>



<div id="inicioFondo" style="
  position:fixed;
  top:0; left:0; width:100%; height:100%;
  background:url('models/barco3.jpg') no-repeat center/cover;
  background-size:cover;
  z-index:99999;
"></div>

<div id="panelHorizontal">Toca para continuar</div>

<button id="btnJugar" style="
  position:absolute; top:90%; left:90%;
  transform:translate(-50%,-50%);
  background: gray;
  border-radius: 5px;
  border: 2px solid black;
  z-index:100000;
  padding:20px 40px; font-size:24px;
  color:black; cursor:pointer;
">
  Jugar
</button>


<!-- Panel de carga -->
<div id="loadingPanel" style="
  position:fixed; top:0; left:0; width:100%; height:100%;
  background:#111; display:flex; flex-direction:column;
  align-items:center; justify-content:center; z-index:9998;
  color:white; display:none;
">
<div id="loadingContainer" style="
  position:absolute; top:50%; left:50%;
  transform:translate(-50%,-50%);
  text-align:center;
  z-index:100000;
">
  <div id="loadingText" style="
    font-size:36px;
    color:white;
    -webkit-text-stroke: 2px black; /* borde negro m√°s grueso */
    margin-bottom:20px;
  ">
    Cargando...
  </div>
  <svg width="180" height="180" style="display:block; margin:0 auto;">
    <circle cx="90" cy="90" r="80" stroke="black" stroke-width="14" fill="none"/> <!-- borde negro m√°s grueso -->
    <circle id="progressCircle" cx="90" cy="90" r="80" stroke="#1e90ff" stroke-width="12" fill="none"
      stroke-dasharray="502.65" stroke-dashoffset="502.65" transform="rotate(-90 90 90)"/>
  </svg>
</div>

<div id="progressText" style="
  position:absolute; top:60%; left:50%;
  transform:translate(-50%,-50%);
  font-size:24px;
  color:white; /* color del texto */
  -webkit-text-stroke: 1px black; /* borde negro del texto */
  z-index:100000;
">
  0%
</div>

  <div id="bgContainer" style="
    position:absolute; top:0; left:0; width:100%; height:100%; overflow:hidden; z-index:-1;
  "></div>
</div>

<!-- Botones invisibles -->
<button id="btnCargar" style="display:none;"></button>
<button id="btnAgua" style="display:none;"></button>
<button id="btnModelos" style="display:none;"></button>
<button id="uiToggleBtn"
style="
position:fixed;
top:10px;
left:10px;
z-index:9999;
background:#0008;
color:white;
border:2px solid white;
padding:8px 14px;
border-radius:8px;
font-size:14px;">
UI
</button>

<div id="joystick"><div id="stick"></div></div>
<div id="cameraPanel"></div>
<button id="btnPick" style="
  position:fixed;
  bottom:20px;
  right:20px;
  width:60px;
  height:60px;
  border:none;
  background:none;
  padding:0;
  display:none;
">
  <img id="btnPickImg" src="models/agarrar.png" style="width:100%;height:100%;object-fit:contain;">
</button>

<button id="pauseBtn">Pausa</button>

<div id="pausePanel">
  <div id="pauseContent">
    <button id="resumeBtn">Reanudar</button>
    <button id="settingsBtn">Ajustes</button>

    <div id="settingsPanel">
      <div id="settingsScroll">
        <label>
  Sensibilidad de c√°mara:
  <input type="range" id="cameraSensitivity" min="0.0005" max="0.01" step="0.0001" value="0.0025">
  <span id="cameraSensitivityValue">0.0025</span>
</label>

        <label>
          Distancia de renderizado:
          <input type="range" id="renderDist" min="20" max="500" value="100">
          <span id="renderDistValue">100</span>
        </label>

        <label>
          <input type="checkbox" id="fogToggle" checked>
          Activar niebla
        </label>

        <label>
          <input type="checkbox" id="transparentToggle">
          Activar texturas transparentes
        </label>

        <label>
          Calidad (Pixel Ratio):
          <input type="range" id="pixelRatioSlider" min="0" max="2" step="0.05" value="0.75">
          <span id="pixelRatioValue">0.75</span>
        </label>

        <fieldset id="filmControls">
          <legend>FilmPass (Pel√≠cula)</legend>
          <label>Intensidad del ruido: <input type="range" id="filmNoise" min="0" max="0.5" step="0.005" value="0"><span id="filmNoiseVal">0</span></label>
          <label>Intensidad de l√≠neas de escaneo: <input type="range" id="filmScanline" min="0" max="0.5" step="0.005" value="0"><span id="filmScanlineVal">0</span></label>
          <label>Escala de grises: <input type="checkbox" id="filmGray" checked></label>
        </fieldset>

        <fieldset id="bokehControls">
          <legend>BokehPass (Profundidad de campo)</legend>
          <label>Enfoque (Focus): <input type="range" id="bokehFocus" min="0" max="50" step="0.5" value="50"><span id="bokehFocusVal">50</span></label>
          <label>Apertura: <input type="range" id="bokehAperture" min="0.0000" max="0.001" step="0.00001" value="0.00021"><span id="bokehApertureVal">0.00021</span></label>
          <label>Desenfoque m√°ximo: <input type="range" id="bokehMaxBlur" min="0.00" max="0.02" step="0.001" value="0.02"><span id="bokehMaxBlurVal">0.02</span></label>
        </fieldset>

     <label id="postProcessLabel">
  <input type="checkbox" id="postProcessToggle">
  Activar postprocesado
</label>

      </div>
    </div>
  </div>
</div>
<audio id="ambientSound" src="models/ambiental.mp3" preload="auto"></audio>
<audio id="stepSound" src="models/pasos.mp3" preload="auto"></audio>
<audio id="underwaterSound" src="models/bajo_agua.mp3" preload="auto"></audio>


<script type="module">
import * as THREE from "https://esm.sh/three@0.162.0";
import { GLTFLoader } from "https://esm.sh/three@0.162.0/examples/jsm/loaders/GLTFLoader.js";
import { EffectComposer } from "https://esm.sh/three@0.162.0/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://esm.sh/three@0.162.0/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "https://esm.sh/three@0.162.0/examples/jsm/postprocessing/UnrealBloomPass.js";
import { FilmPass } from "https://esm.sh/three@0.162.0/examples/jsm/postprocessing/FilmPass.js";
import { BokehPass } from "https://esm.sh/three@0.162.0/examples/jsm/postprocessing/BokehPass.js";
// --- AUDIO AMBIENTAL ---
const ambientSound = document.getElementById("ambientSound");
ambientSound.volume = 0.01;     // volumen inicial ultra bajo
ambientSound.loop = false;      // manual loop (por seguridad en m√≥viles)

// Reiniciar manualmente cuando termine
ambientSound.addEventListener("ended", () => {
    ambientSound.currentTime = 0;
    ambientSound.play();
});

// Funci√≥n para subir el volumen poco a poco
function fadeInAmbient(duration = 5000) {
    let start = ambientSound.volume;
    let end = 0.35;   // volumen final
    let step = (end - start) / (duration / 50);

    let interval = setInterval(() => {
        ambientSound.volume += step;
        if (ambientSound.volume >= end) {
            ambientSound.volume = end;
            clearInterval(interval);
        }
    }, 50);
}
// --- SONIDO DE PASOS ---
const stepSound = document.getElementById("stepSound");
stepSound.volume = 0.35;     // volumen normal
stepSound.loop = false;      // loopeo manual



// Reiniciar sonido autom√°ticamente
stepSound.addEventListener("ended", () => {
    stepSound.currentTime = 0;
    stepSound.play().catch(()=>{});
});
// --- SONIDO AMBIENTAL ---

ambientSound.volume = 0.01;
ambientSound.loop = false;

// --- SONIDO BAJO AGUA ---
const underwaterSound = document.getElementById("underwaterSound");
underwaterSound.volume = 0.4;
underwaterSound.loop = false;
underwaterSound.volume = 0.4;
underwaterSound.currentTime = 0;
underwaterSound.play().catch(()=>{});

// loop manual para ambos
ambientSound.addEventListener("ended", ()=>{ ambientSound.currentTime = 0; ambientSound.play().catch(()=>{}); });
underwaterSound.addEventListener("ended", ()=>{ underwaterSound.currentTime = 0; underwaterSound.play().catch(()=>{}); });
underwaterSound.volume = 0.4;
underwaterSound.currentTime = 0;
underwaterSound.play().catch(()=>{});

// --- SONIDO DE PASOS ---

stepSound.volume = 0.35;
stepSound.loop = false;

stepSound.addEventListener("ended", ()=>{
    stepSound.currentTime = 0;
    stepSound.play().catch(()=>{});
});

let pasosActivos = false;


// --- ESCENA ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.Fog(0x87ceeb, 20, 100);

// --- RAYCASTER GLOBAL ---
const raycaster = new THREE.Raycaster();

// --- RENDERER ---
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);
// --- CIELO 360 JPG ---
const textureLoader = new THREE.TextureLoader();
textureLoader.load("models/cielo.jpg", (texture) => {
  texture.mapping = THREE.EquirectangularReflectionMapping;
  scene.background = texture;
  
});
// Definir spawnPoint y velocidad como let (no const)



// Funci√≥n para resetear al jugador
function respawnPlayer() {
  player.position.copy(spawnPoint);   // mover al jugador al spawn
  playerVelocity.set(0, 0, 0);        // resetear velocidad
  // si hay gravedad o animaciones, reiniciarlas aqu√≠
}



let playerHealth = 100;
let maxHealth = 100;
let gameOverActive = false;
// --- PLAYER ---
const player = new THREE.Object3D();
scene.add(player);
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 200);
camera.position.set(0,10,0);
player.add(camera);
const composer = new EffectComposer(renderer);
const renderPass = new RenderPass(scene, camera);
composer.addPass(renderPass);
const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(innerWidth, innerHeight),
  0.5, // intensidad
  0.5, // radio
  0.2  // umbral
);
composer.addPass(bloomPass);
const filmPass = new FilmPass(0.01, 0.05, 648, false);
composer.addPass(filmPass);
const bokeh = new BokehPass(scene, camera, {
  focus: 10,       // distancia n√≠tida
  aperture: 0.00021,// intensidad de desenfoque
  maxblur: 0.02   // m√°ximo desenfoque
});
composer.addPass(bokeh);

// --- CUBO DE COLISI√ìN ---
const playerCollider = new THREE.Mesh(
  new THREE.BoxGeometry(1,2,1),
  new THREE.MeshBasicMaterial({visible:false})
);
player.add(playerCollider);

// --- LUCES ---
const sun = new THREE.DirectionalLight(0xffd080, 2);
sun.position.set(50,100,50);
scene.add(sun);
scene.add(new THREE.AmbientLight(0xffffff, 0.4));

// --- TERRAIN BARCO ---
const loader = new GLTFLoader();
let terrain = null;
const btnCargar = document.createElement("button");
btnCargar.textContent = "Cargar Barco";
btnCargar.style.position = "absolute";
btnCargar.style.top = "10px";
btnCargar.style.left = "10px";
btnCargar.style.display = "none";
btnCargar.style.zIndex = "9999";
document.body.appendChild(btnCargar);

btnCargar.onclick = () => {

  loader.load("models/Barco.gltf", gltf => {
    terrain = gltf.scene;
    terrain.scale.set(1,1,1);
    scene.add(terrain);

    const spawnPoint = new THREE.Vector3(10, 10, 0);
    player.position.copy(spawnPoint);
  });

  btnCargar.style.display = "none";
};

// --- SLIDER PIXEL RATIO ---
const pixelRatioSlider = document.getElementById('pixelRatioSlider');
const pixelRatioValue = document.getElementById('pixelRatioValue');

pixelRatioSlider.addEventListener('input', () => {
  const ratio = parseFloat(pixelRatioSlider.value);
  pixelRatioValue.textContent = ratio.toFixed(2);
  renderer.setPixelRatio(window.devicePixelRatio * ratio);
});
const filmNoiseSlider = document.getElementById('filmNoise');
const filmNoiseVal = document.getElementById('filmNoiseVal');
filmNoiseSlider.addEventListener('input', ()=>{
  filmPass.uniforms['nIntensity'].value = parseFloat(filmNoiseSlider.value);
  filmNoiseVal.textContent = parseFloat(filmNoiseSlider.value).toFixed(3);
});

const filmScanlineSlider = document.getElementById('filmScanline');
const filmScanlineVal = document.getElementById('filmScanlineVal');
filmScanlineSlider.addEventListener('input', ()=>{
  filmPass.uniforms['sIntensity'].value = parseFloat(filmScanlineSlider.value);
  filmScanlineVal.textContent = parseFloat(filmScanlineSlider.value).toFixed(3);
});

const filmGrayCheckbox = document.getElementById('filmGray');
filmGrayCheckbox.addEventListener('change', ()=>{
  filmPass.uniforms['grayscale'].value = filmGrayCheckbox.checked ? 1 : 0;
});
const bokehFocusSlider = document.getElementById('bokehFocus');
const bokehFocusVal = document.getElementById('bokehFocusVal');
bokehFocusSlider.addEventListener('input', ()=>{
  bokeh.materialBokeh.uniforms['focus'].value = parseFloat(bokehFocusSlider.value);
  bokehFocusVal.textContent = parseFloat(bokehFocusSlider.value).toFixed(1);
});

const bokehApertureSlider = document.getElementById('bokehAperture');
const bokehApertureVal = document.getElementById('bokehApertureVal');
bokehApertureSlider.addEventListener('input', ()=>{
  bokeh.materialBokeh.uniforms['aperture'].value = parseFloat(bokehApertureSlider.value);
  bokehApertureVal.textContent = parseFloat(bokehApertureSlider.value).toFixed(5);
});

const bokehMaxBlurSlider = document.getElementById('bokehMaxBlur');
const bokehMaxBlurVal = document.getElementById('bokehMaxBlurVal');
bokehMaxBlurSlider.addEventListener('input', ()=>{
  bokeh.materialBokeh.uniforms['maxblur'].value = parseFloat(bokehMaxBlurSlider.value);
  bokehMaxBlurVal.textContent = parseFloat(bokehMaxBlurSlider.value).toFixed(3);
});
const postProcessToggle = document.getElementById('postProcessToggle');

// Asegurarse de que inicie desactivado
postProcessToggle.checked = false;
composer.passes.forEach(pass => {
  if (pass !== composer.passes[0]) { // dejar solo el RenderPass activo
    pass.enabled = false;
  }
});

// Listener ya existente
postProcessToggle.addEventListener('change', () => {
  const enabled = postProcessToggle.checked;
  composer.passes.forEach(pass => {
    if (pass !== composer.passes[0]) {
      pass.enabled = enabled;
    }
  });
});

const cameraSensitivitySlider = document.getElementById('cameraSensitivity');
const cameraSensitivityValue = document.getElementById('cameraSensitivityValue');
let lookSensitivity = 0.0025; // valor por defecto

cameraSensitivitySlider.addEventListener('input', ()=>{
  lookSensitivity = parseFloat(cameraSensitivitySlider.value);
  cameraSensitivityValue.textContent = lookSensitivity.toFixed(4);
});

// --- MOVIMIENTO FPS ---
let yaw=0, pitch=0, joystickInput={x:0,y:0}, speed=10;
const joystick=document.getElementById('joystick');
const stick=document.getElementById('stick');
let joystickId=null, startX=0, startY=0;

joystick.addEventListener('touchstart', e=>{
  for(const t of e.changedTouches){
    if(joystickId===null){ joystickId=t.identifier; startX=t.clientX; startY=t.clientY; break; }
  }
});
joystick.addEventListener('touchmove', e=>{
  if(joystickId===null) return;
  for(const t of e.changedTouches){
    if(t.identifier===joystickId){
      const dx=t.clientX-startX, dy=t.clientY-startY;
      const maxDist=40;
      const moveX=Math.max(-maxDist,Math.min(maxDist,dx));
      const moveY=Math.max(-maxDist,Math.min(maxDist,dy));
      stick.style.transform=`translate(${moveX}px,${moveY}px)`;
      joystickInput.x=moveX/maxDist; joystickInput.y=-moveY/maxDist; break;
    }
  }
});
joystick.addEventListener('touchend', e=>{
  for(const t of e.changedTouches){
    if(t.identifier===joystickId){ stick.style.transform='translate(0,0)'; joystickInput.x=0; joystickInput.y=0; joystickId=null; break; }
  }
});

// --- TRANSPARENCIA ---
const transparentToggle = document.getElementById('transparentToggle');
transparentToggle.addEventListener('change', ()=>{
  if(!terrain) return;
  const enable = transparentToggle.checked;
  terrain.traverse(n=>{
    if(n.isMesh && n.material.map){
      n.material.transparent = enable;
      n.material.needsUpdate = true;
    }
  });
});

// --- PANEL CAMARA ---
const cameraPanel=document.getElementById('cameraPanel');
let lookId=null, lookStartX=0, lookStartY=0;
cameraPanel.addEventListener('touchstart', e=>{
  for(const t of e.changedTouches){
    if(lookId===null){ lookId=t.identifier; lookStartX=t.clientX; lookStartY=t.clientY; break; }
  }
});
cameraPanel.addEventListener('touchmove', e=>{
  if(lookId===null) return;
  for(const t of e.changedTouches){
    if(t.identifier===lookId){
      const dx=t.clientX-lookStartX, dy=t.clientY-lookStartY;
      yaw -= dx * lookSensitivity;
      pitch -= dy * lookSensitivity;
      pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
      lookStartX = t.clientX;
      lookStartY = t.clientY;
      break;
    }
  }
});

cameraPanel.addEventListener('touchend', e=>{ for(const t of e.changedTouches){ if(t.identifier===lookId) lookId=null; } });

// --- PAUSA / AJUSTES ---
const pauseBtn=document.getElementById('pauseBtn');
const pausePanel=document.getElementById('pausePanel');
const resumeBtn=document.getElementById('resumeBtn');
const settingsBtn=document.getElementById('settingsBtn');
const settingsPanel=document.getElementById('settingsPanel');
const renderDistInput=document.getElementById('renderDist');
const renderDistValue=document.getElementById('renderDistValue');
const fogToggle=document.getElementById('fogToggle');
let paused=false;

pauseBtn.addEventListener('click', ()=>{ paused=true; pausePanel.style.display='flex'; });
resumeBtn.addEventListener('click', ()=>{ paused=false; pausePanel.style.display='none'; settingsPanel.style.display='none'; });
settingsBtn.addEventListener('click', ()=>{ settingsPanel.style.display=(settingsPanel.style.display==='flex')?'none':'flex'; });
renderDistInput.addEventListener('input', ()=>{
  const val=parseFloat(renderDistInput.value);
  camera.far=val; camera.updateProjectionMatrix();
  scene.fog.far=val; scene.fog.near=val/5;
  renderDistValue.textContent=val;
});
fogToggle.addEventListener('change', ()=>{ scene.fog = fogToggle.checked ? new THREE.Fog(0x87ceeb, camera.far/5, camera.far) : null; });

// --- RAYCASTING Y F√çSICAS ---
const down = new THREE.Vector3(0,-1,0);

function updatePhysics(delta) {
  if(!terrain) return;

  const playerPos = playerCollider.getWorldPosition(new THREE.Vector3());
  raycaster.set(playerPos.clone().add(new THREE.Vector3(0,5,0)), new THREE.Vector3(0,-1,0));
  const intersects = raycaster.intersectObject(terrain, true);

  if(intersects.length > 0){
    const groundY = intersects[0].point.y + 1;

    // Gravedad
    if(player.position.y > groundY){
      velocityY -= 9.8 * delta;
      player.position.y += velocityY * delta;
      if(player.position.y < groundY) velocityY = 0;
    } else {
      velocityY = 0;
      player.position.y = groundY;
    }
  }

  // Detectar agua
  if(player.position.y <= waterLevel && !fallingUnderwater){
    startWaterCinematic();             // iniciar overlay
    player.position.y = waterLevel - 5; // sumergir jugador bajo el agua
    velocityY = 0;                     // detener ca√≠da
  }
}

// --- Detectar colisiones horizontales ---
function checkWalls(deltaX, deltaZ) {
  if (!terrain) return { dx: deltaX, dz: deltaZ };

  const directions = [
    new THREE.Vector3(deltaX, 0, 0),
    new THREE.Vector3(0, 0, deltaZ)
  ];
  let dx = deltaX, dz = deltaZ;

  directions.forEach((dir) => {
    const origin = playerCollider.getWorldPosition(new THREE.Vector3());
    origin.y += 1; // üîπ eleva el rayo al centro del jugador (ajusta seg√∫n tu altura)
    raycaster.set(origin, dir.clone().normalize());
    const intersects = raycaster.intersectObject(terrain, true);
    if (intersects.length > 0 && intersects[0].distance < 0.8) { // menor distancia = m√°s preciso
      if (dir.x !== 0) dx = 0;
      if (dir.z !== 0) dz = 0;
    }
  });

  return { dx, dz };
}

const maxStepHeight = 1.0; // altura m√°xima que puede subir

function updatePlayerHeight(){
  if(terrain){
    raycaster.set(player.position.clone().add(new THREE.Vector3(0,10,0)), down);
    const intersects = raycaster.intersectObject(terrain, true);
    if(intersects.length>0){
      const targetY = intersects[0].point.y + playerHeightOffset;
      // permitir subir solo si diferencia < maxStepHeight
      if(targetY - player.position.y <= maxStepHeight){
        player.position.y = targetY;
      }
    }
  }
}
// --- AGUA ANIMADA CON TEXTURA ---

let water = null; // ‚Üê definido afuera

const btnAgua = document.createElement("button");
btnAgua.textContent = "Cargar Agua";
btnAgua.style.position = "absolute";
btnAgua.style.top = "60px";
btnAgua.style.left = "10px";
btnAgua.style.display = "none";
btnAgua.style.zIndex = "9999";
document.body.appendChild(btnAgua);

btnAgua.onclick = () => {

  const waterGeo = new THREE.PlaneGeometry(3500, 3500, 100, 100);
  const waterMat = new THREE.MeshPhongMaterial({
    color: 0x1e90ff,
    side: THREE.DoubleSide,
    transparent: false,
    opacity: 0.10
  });

  water = new THREE.Mesh(waterGeo, waterMat); // ‚Üê ahora s√≠ existe
  water.rotation.x = -Math.PI/2;
  
  water.position.y = -10;
  scene.add(water);

  textureLoader.load('models/agua.jpg', (texture)=>{
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(10,10);
    water.material.map = texture;
    water.material.needsUpdate = true;
  });

  btnAgua.style.display = "none";
};

// --- Par√°metros del agua ---
const waterLevel = -10;        // altura de la superficie del agua
let inWater = false;  
let usandoAmbientalNormal = true; // si el jugador est√° en el agua
let swimSpeed = 0.5;           // velocidad horizontal en el agua
let buoyancy = -10;           // fuerza de flotaci√≥n
let swimUpVelocity = 10;      // velocidad vertical en el agua

let cinematicProgress = 0;

const waterBottom = waterLevel - 100; // profundidad del fondo




let fadeOverlay;

// --- Definir variables al inicio ---
const spawnPoint = new THREE.Vector3(0, 10, 0); // punto de inicio
let playerVelocity = new THREE.Vector3(0, 0, 0);
let velocityY = 0;
let fallingUnderwater = false;
let gameOver = false;

function resetPlayer() {
  console.log("Reseteando jugador al spawnPoint");

  // Teletransportar jugador y collider
  player.position.copy(spawnPoint);
  player.rotation.set(0, 0, 0);

  if (playerCollider) {
    playerCollider.position.copy(spawnPoint);
  }

  // Teletransportar c√°mara
  camera.position.copy(spawnPoint.clone().add(new THREE.Vector3(0, 2, 0)));
  camera.rotation.set(0, 0, 0);

  // Reiniciar efectos visuales
  fallingUnderwater = false;
  gameOver = false;
  cinematicProgress = 0;

  const overlay = document.getElementById("waterOverlay");
  if (overlay) overlay.remove();
}

// --- Detectar ca√≠da al agua ---


// --- Cinem√°tica de agua simplificada ---
function startWaterCinematic() {
  if (fallingUnderwater) return;
  fallingUnderwater = true;

  // overlay para efecto visual
  let fadeOverlay = document.createElement("div");
  fadeOverlay.id = "waterOverlay";
  fadeOverlay.style.position = "fixed";
  fadeOverlay.style.top = 0;
  fadeOverlay.style.left = 0;
  fadeOverlay.style.width = "100%";
  fadeOverlay.style.height = "100%";
  fadeOverlay.style.background = "rgba(0,0,0,0)"; // inicio transparente
  fadeOverlay.style.transition = "background 2s linear"; // transici√≥n suave
  fadeOverlay.style.pointerEvents = "none";
  document.body.appendChild(fadeOverlay);

  // empezar a oscurecer despu√©s de 5 segundos
  setTimeout(() => {
    fadeOverlay.style.background = "rgba(0,0,0,1)"; // negro total
  }, 5000);

  // reiniciar jugador despu√©s de 7 segundos (opcional)
  setTimeout(resetPlayer, 7000);
}



function updateWaterMovement(delta) {
  if (!terrain) return;
  const playerPos = player.position.clone();

  // Raycast hacia abajo para detectar suelo
  const origin = playerCollider.getWorldPosition(new THREE.Vector3()).add(new THREE.Vector3(0,1,0));
  raycaster.set(origin, new THREE.Vector3(0,-1,0));
  const intersects = raycaster.intersectObject(terrain, true);

  // Determinar si el jugador debe caer o entrar al agua
  if (intersects.length > 0) {
    const groundY = intersects[0].point.y + 1;
    if (playerPos.y > groundY) {
      if (!inWater) velocityY -= 9.8 * delta; // gravedad normal
      player.position.y += velocityY * delta;
      if (player.position.y < groundY) {
        player.position.y = groundY;
        velocityY = 0;
      }
    }
  } else {
    // sin suelo, caer hasta llegar al agua
    if (playerPos.y > waterLevel) {
      velocityY -= 9.8 * delta;
      player.position.y += velocityY * delta;
      if (playerPos.y <= waterLevel) {
    inWater = true;       // entrar al agua normalmente
    velocityY = 0;
}

    } else {
      inWater = true; // jugador ya en agua
    }
  }

  // --- F√≠sica de agua ---
  if (inWater) {
    const depth = waterLevel - player.position.y;
    swimUpVelocity += buoyancy * delta * Math.min(depth, 1);
    if (swimUpVelocity > 10) swimUpVelocity = 10;
    player.position.y += swimUpVelocity * delta;

    // movimiento en la direcci√≥n de la c√°mara
    const moveX = -Math.sin(yaw) * joystickInput.y + Math.cos(yaw) * joystickInput.x;
    const moveZ = -Math.cos(yaw) * joystickInput.y - Math.sin(yaw) * joystickInput.x;
    player.position.x += moveX * swimSpeed * delta;
    player.position.z += moveZ * swimSpeed * delta;

    // salir del agua si toca superficie
    if (player.position.y >= waterLevel) {
      inWater = false;
      swimUpVelocity = 0;
    }
  }
}
const mira = document.createElement('div');
mira.style.position = 'absolute';
mira.style.left = '50%';
mira.style.top = '50%';
mira.style.width = '6px';
mira.style.height = '6px';
mira.style.borderRadius = '50%';
mira.style.transform = 'translate(-50%, -50%)';
mira.style.background = '#fff';
mira.style.pointerEvents = 'none';
document.body.appendChild(mira);

const btnPick = document.getElementById('btnPick');
const btnPickImg = document.getElementById('btnPickImg');

btnPick.onclick = () => {
    if (!objetoAgarrado) return;

    // --- SI EL OBJETO YA EST√Å EN LA MANO ‚Üí SOLTAR ---
    if (objetoAgarrado.parent === camera) {

        btnPickImg.src = "models/agarrar.png";

        const w = objetoAgarrado.userData.cfg?.world;

        camera.remove(objetoAgarrado);
        scene.add(objetoAgarrado);

        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const inter = raycaster.intersectObjects(scene.children, true);

        let destino = new THREE.Vector3();

        if (inter.length > 0) {
            destino.copy(inter[0].point);
            destino.y += 0.05;
        } else {
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            destino.copy(camera.position).add(forward.multiplyScalar(2));
        }

        const destinoQuat = new THREE.Quaternion().setFromEuler(
            new THREE.Euler(w.rot.x, w.rot.y, w.rot.z)
        );
        const destinoScale = new THREE.Vector3(w.scale, w.scale, w.scale);

        interpolarTransform(objetoAgarrado, destino, destinoQuat, destinoScale, 0.25);

        objetoAgarrado = null;
        btnPick.style.display = "none";
        return;
    }

    // --- SI EL OBJETO EST√Å EN EL SUELO ‚Üí AGARRAR ---
    btnPickImg.src = "models/soltar.png";
    btnPick.style.display = "block";   // üî• MOSTRAR EL BOT√ìN INMEDIATO

    const obj = objetoAgarrado;        // referencia por seguridad

    // üî• MARCAR DESDE YA QUE EST√Å EN LA MANO (antes de animaci√≥n)
    objetoAgarrado = obj;
    obj.estaEnMano = true;

    colocarEnMano(obj);

    // Al terminar animaci√≥n: asegurar parent final
    setTimeout(() => {
        obj.estaEnMano = false;
    }, 250);
};

// Modelos con rutas y posiciones
const modelos = [
  {
    name: 'cana',
    url: 'models/Ca√±a_de_pesca.gltf',
    cfg: {
      world: { pos: { x: 0, y: 5, z: 0 }, rot: { x: 0, y: 0, z: 0 }, scale: 5 },
      hand: { pos: { x: 0.3, y: -0.5, z: -1 }, rot: { x: 0, y: Math.PI/2, z:0 }, scale: 1.2 }
    }
  },
  {
    name: 'manzana',
    url: 'models/manana.gltf',
    cfg: {
      world: { pos: { x: 2, y: 5, z: 1 }, rot: { x: 0, y: Math.PI/4, z: 0 }, scale: 2 },
      hand: { pos: { x: 0.25, y: -0.4, z: -0.9 }, rot: { x:0, y:Math.PI/3, z:0 }, scale: 0.5 }
    }
  },
  {
    name: 'barril',
    url: 'models/barril.gltf',
    cfg: {
      world: { pos: { x: -2, y: 5, z: -1 }, rot: { x:0, y:0, z:0 }, scale: 3 },
      hand: { pos: { x: 1, y: -1, z: -1 }, rot: { x:0, y:1, z:0 }, scale: 0.5 }
    }
  }
];

let objetosEnEscena = [];
let objetoAgarrado = null;

const btnModelos = document.createElement("button");
btnModelos.textContent = "Cargar Modelos";
btnModelos.style.position = "absolute";
btnModelos.style.top = "110px";
btnModelos.style.display = "none";
btnModelos.style.left = "10px";
btnModelos.style.zIndex = "9999";
document.body.appendChild(btnModelos);

btnModelos.onclick = () => {

  modelos.forEach(m=>{
    loader.load(m.url, gltf=>{
      const obj = gltf.scene;
      obj.userData.cfg = m.cfg || {};

      if(obj.userData.cfg.world){
        const w = obj.userData.cfg.world;
        obj.position.set(w.pos.x, w.pos.y, w.pos.z);
        obj.rotation.set(w.rot.x, w.rot.y, w.rot.z);
        obj.scale.set(w.scale, w.scale, w.scale);

        if (terrain) {
          terrain.add(obj);
          obj.position.set(w.pos.x, w.pos.y - terrain.position.y, w.pos.z);
        } else {
          scene.add(obj);
        }
      } else {
        scene.add(obj);
      }

      objetosEnEscena.push(obj);
    });
  });

  btnModelos.style.display = "none";
};
function interpolarTransform(obj, destinoPos, destinoQuat, destinoScale, duracion = 0.25) {
    // üî• Asegurar matrices actualizadas
    camera.updateMatrixWorld(true);
    obj.updateMatrixWorld(true);

    // 1Ô∏è‚É£ Obtener inicio REAL en coordenadas WORLD
    const inicioPos = new THREE.Vector3();
    const inicioQuat = new THREE.Quaternion();
    const inicioScale = new THREE.Vector3();

    obj.getWorldPosition(inicioPos);
    obj.getWorldQuaternion(inicioQuat);
    obj.getWorldScale(inicioScale);

    // 2Ô∏è‚É£ Pasar el objeto a la escena ra√≠z SIN perder la pose mundial
    if (obj.parent !== scene) {
        obj.parent.remove(obj);
        scene.add(obj);

        obj.position.copy(inicioPos);
        obj.quaternion.copy(inicioQuat);
        obj.scale.copy(inicioScale);
    }

    // 3Ô∏è‚É£ Animaci√≥n usando WORLD space
    const t0 = performance.now();
    const durMs = duracion * 1000;

    const pos = new THREE.Vector3();
    const sca = new THREE.Vector3();
    const rot = new THREE.Quaternion();

    function animar() {
        const elapsed = performance.now() - t0;
        const k = Math.min(elapsed / durMs, 1);

        // posici√≥n
        pos.copy(inicioPos).lerp(destinoPos, k);
        obj.position.copy(pos);

        // rotaci√≥n
        rot.copy(inicioQuat).slerp(destinoQuat, k);
        obj.quaternion.copy(rot);

        // escala
        sca.copy(inicioScale).lerp(destinoScale, k);
        obj.scale.copy(sca);

        if (k < 1) {
            requestAnimationFrame(animar);
        }
    }

    animar();
}

// Funci√≥n para colocar objeto en la mano
function colocarEnMano(obj) {
    const h = obj.userData.cfg.hand;

    // posici√≥n destino en espacio local de la c√°mara
    const destino = new THREE.Vector3(h.pos.x, h.pos.y, h.pos.z);
    const destinoQuat = new THREE.Quaternion().setFromEuler(
        new THREE.Euler(h.rot.x, h.rot.y, h.rot.z)
    );
    const destinoScale = new THREE.Vector3(h.scale, h.scale, h.scale);

    // convertimos destino a coordenadas MUNDIALES
    const destinoWorld = destino.clone().applyMatrix4(camera.matrixWorld);
    const destinoWorldQuat = destinoQuat.clone().premultiply(camera.quaternion);

    // agregar a la escena temporalmente para interpolar en WORLD
    scene.add(obj);

    interpolarTransform(obj, destinoWorld, destinoWorldQuat, destinoScale, 0.2);

    // cuando termine la animaci√≥n, meterlo en la c√°mara SIN romper la posici√≥n final
    setTimeout(() => {
        camera.add(obj);

        // fijamos la posici√≥n relativa exacta
        obj.position.copy(destino);
        obj.quaternion.copy(destinoQuat);
        obj.scale.copy(destinoScale);
    }, 220);
}

function soltarConAnimacion(obj) {
    const w = obj.userData.cfg.world;
    const h = obj.userData.cfg.hand;

    // 1Ô∏è‚É£ Calcular la posici√≥n REAL en el mundo del objeto en la mano
    const startPos = new THREE.Vector3(h.pos.x, h.pos.y, h.pos.z);

    // convertir posici√≥n local de la mano ‚Üí a WORLD
    startPos.applyMatrix4(camera.matrixWorld);

    // calcular rotaci√≥n WORLD real del objeto en la mano
    const startQuat = new THREE.Quaternion()
        .setFromEuler(new THREE.Euler(h.rot.x, h.rot.y, h.rot.z))
        .premultiply(camera.quaternion);

    // escala inicial (la de la mano)
    const startScale = new THREE.Vector3(h.scale, h.scale, h.scale);

    // 2Ô∏è‚É£ Mover el objeto a la escena sin perder su pose de mano
    camera.remove(obj);
    scene.add(obj);

    obj.position.copy(startPos);
    obj.quaternion.copy(startQuat);
    obj.scale.copy(startScale);

    // 3Ô∏è‚É£ Calcular destino en el mundo
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const inter = raycaster.intersectObjects(scene.children, true);

    let endPos = new THREE.Vector3();
    if (inter.length > 0) {
        endPos.copy(inter[0].point);
        endPos.y += 0.05;
    } else {
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        endPos.copy(camera.position).add(forward.multiplyScalar(2));
    }

    // Rotaci√≥n final deseada
    const endQuat = new THREE.Quaternion().setFromEuler(
        new THREE.Euler(w.rot.x, w.rot.y, w.rot.z)
    );

    const endScale = new THREE.Vector3(w.scale, w.scale, w.scale);

    // 4Ô∏è‚É£ Punto de control para el arco (curva hacia arriba)
    const controlPoint = startPos.clone().lerp(endPos, 0.5);
    controlPoint.y += 1.5;  // altura del arco üî•

    // 5Ô∏è‚É£ Animaci√≥n: trayectoria parab√≥lica hacia abajo
    const t0 = performance.now();
    const dur = 0.35;

    function animar() {
        const t = (performance.now() - t0) / (dur * 1000);
        const k = Math.min(t, 1);

        // üéØ Interpolaci√≥n cuadr√°tica tipo B√©zier (arco)
        const a = startPos.clone().multiplyScalar((1 - k) * (1 - k));
        const b = controlPoint.clone().multiplyScalar(2 * (1 - k) * k);
        const c = endPos.clone().multiplyScalar(k * k);

        const pos = a.add(b).add(c);
        obj.position.copy(pos);

        // rotaci√≥n gradual
        obj.quaternion.slerpQuaternions(startQuat, endQuat, k);

        // escala gradual
        obj.scale.lerpVectors(startScale, endScale, k);

        if (k < 1) requestAnimationFrame(animar);
    }

    animar();
}

function revisarObjetoCercano() {
// üî• Si un objeto est√° siendo agarrado (animando o ya en mano)
    if (objetoAgarrado && (objetoAgarrado.parent === camera || objetoAgarrado.estaEnMano)) {
        btnPickImg.src = "models/soltar.png";
        btnPick.style.display = "block";
        return;
    }
  raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
  const inter = raycaster.intersectObjects(objetosEnEscena, true);

  if (inter.length > 0) {
    let obj = inter[0].object;

    while (!obj.userData.cfg && obj.parent) obj = obj.parent;

    if (!obj.userData.cfg) {
      btnPick.style.display = "none";
      objetoAgarrado = null;
      return;
    }

    objetoAgarrado = obj;

    // Icono de agarrar
    btnPickImg.src = "models/agarrar.png";

    btnPick.style.display = "block";
  } else {
    btnPick.style.display = "none";
    objetoAgarrado = null;
  }
}

// --- SHADER UNDERWATER ---
const UnderwaterShader = {
  uniforms: {
    "tDiffuse": { value: null },
    "time": { value: 0 },
    "depth": { value: 0 }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = vec4( position, 1.0 );
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float time;
    uniform float depth;
    varying vec2 vUv;

    void main() {
        vec2 uv = vUv;

        // ondas de distorsi√≥n
        float wave = sin(uv.y * 12.0 + time * 2.0) * 0.015;
        uv.x += wave;
        uv.y += sin(uv.x * 8.0 + time * 1.5) * 0.015;

        vec4 color = texture2D(tDiffuse, uv);

        // tinte azul
        vec3 blueTint = vec3(0.0, 0.25, 0.45);

        // profundidad normalizada
        float d = clamp(depth * 0.12, 0.0, 1.0);

        // mezcla azul seg√∫n profundidad
        color.rgb = mix(color.rgb, blueTint, d * 0.6);

        // contraste reducido
        color.rgb = mix(color.rgb, vec3(0.5), d * 0.25);

        // oscurecimiento gradual
        color.rgb *= 1.0 - d * 0.35;

        // --- FOG VOLUM√âTRICO SUBMARINO ---
        float fogPower = 3.5;   // qu√© tan densa es la niebla
        float fogStart = 0.25;  // cu√°ndo empieza a verse
        float fogAmount = pow(d, fogPower);

        // color de niebla acu√°tica
        vec3 fogColor = vec3(0.0, 0.20, 0.35);

        // mezcla final fog + escena
        color.rgb = mix(color.rgb, fogColor, clamp(fogAmount - fogStart, 0.0, 1.0));

        gl_FragColor = color;
    }
`

};

import { ShaderPass } from "https://esm.sh/three@0.162.0/examples/jsm/postprocessing/ShaderPass.js";

const underwaterPass = new ShaderPass(UnderwaterShader);
underwaterPass.enabled = false;
composer.addPass(underwaterPass);
function updateUnderwater(delta) {

    // 1Ô∏è‚É£ DETECTAR SI EL JUGADOR EST√Å BAJO EL AGUA
    // ------------------------------------------------
    inWater = player.position.y <= waterLevel;


    // 2Ô∏è‚É£ CAMBIO DE SONIDO SEG√öN ESTADO "inWater"
    // ------------------------------------------------

    // Entr√≥ bajo el agua ‚Üí activar sonido bajo agua
    if (inWater && usandoAmbientalNormal) {

        // Pausar sonido ambiental
        if (!ambientSound.paused) {
            ambientSound.pause();
        }

        // Activar sonido bajo el agua
        underwaterSound.currentTime = 0;
        underwaterSound.play().catch(() => {});

        usandoAmbientalNormal = false;
        console.log("üîä Sonido BAJO AGUA activado");
    }

    // Sali√≥ del agua ‚Üí volver al sonido normal
    if (!inWater && !usandoAmbientalNormal) {

        underwaterSound.pause();

        ambientSound.currentTime = 0;
        ambientSound.play().catch(() => {});

        usandoAmbientalNormal = true;
        console.log("üîä Sonido AMBIENTAL activado");
    }


    // 3Ô∏è‚É£ ACTIVACI√ìN / DESACTIVACI√ìN DEL SHADER VISUAL
    // ------------------------------------------------

    // Entr√≥ al agua ‚Üí activar efecto visual
    if (inWater && !underwaterPass.enabled) {

        underwaterPass.enabled = true;
        console.log("üåä Shader de agua ACTIVADO");

        // Solo si tienes cinem√°tica
        startWaterCinematic();
    }

    // Sali√≥ del agua ‚Üí desactivar efecto visual
    else if (!inWater && underwaterPass.enabled) {

        underwaterPass.enabled = false;
        console.log("üåä Shader de agua DESACTIVADO");

        // quitar overlay si existe
        const overlay = document.getElementById("waterOverlay");
        if (overlay) overlay.remove();

        fallingUnderwater = false;
    }


    // 4Ô∏è‚É£ ANIMACI√ìN DE AGUA
    // ------------------------------------------------
    if (underwaterPass.enabled) {
        underwaterPass.uniforms.time.value += delta;
        underwaterPass.uniforms.depth.value = waterLevel - player.position.y;
    }
}

// Funci√≥n para hundir objetos en el agua
function updateObjectsInWater(delta) {
  objetosEnEscena.forEach(obj => {
    if (!obj.userData.cfg || !obj.userData.cfg.world) return;

    // comprobar si el objeto est√° en el agua
    const waterLevelGlobal = waterLevel; // altura del agua
    const objWorldPos = new THREE.Vector3();
    obj.getWorldPosition(objWorldPos);

    if (objWorldPos.y > waterBottom && objWorldPos.y < waterLevelGlobal) {
      // hundir lentamente
      obj.position.y -= 2 * delta; // velocidad de hundimiento
      if (obj.position.y < waterBottom) obj.position.y = waterBottom;
    }
  });
}
// Funci√≥n para colocar un objeto sobre otro y emparentarlo
function colocarSobreObjeto(obj, target) {
  if (!obj || !target) return;

  // conservar posici√≥n mundial antes de emparentar
  const worldPos = new THREE.Vector3();
  const worldQuat = new THREE.Quaternion();
  const worldScale = new THREE.Vector3();
  obj.getWorldPosition(worldPos);
  obj.getWorldQuaternion(worldQuat);
  obj.getWorldScale(worldScale);

  // agregar como hijo del target
  target.add(obj);

  // restaurar transformaciones locales para mantener la posici√≥n relativa
  obj.position.copy(worldPos);
  obj.quaternion.copy(worldQuat);
  obj.scale.copy(worldScale);

  // ajustar posici√≥n relativa al target
  obj.position.sub(target.getWorldPosition(new THREE.Vector3()));
}

const btnJugar = document.getElementById("btnJugar");
const inicioFondo = document.getElementById("inicioFondo");
const loadingPanel = document.getElementById("loadingPanel");
const progressCircle = document.getElementById("progressCircle");
const progressText = document.getElementById("progressText");

const bgContainer = document.getElementById("bgContainer");

const fondoImgs = [
  "models/barco.jpg",
  "models/barco1.jpg",
    "models/barco3.jpg",
  "models/agua.jpg",
  "models/barco2.jpg"
];

function fadeCycle(){
  const src = fondoImgs[Math.floor(Math.random()*fondoImgs.length)];
  const img = document.createElement("div");
  img.style.position = "absolute";
  img.style.top = "0";
  img.style.left = "0";
  img.style.width = "100%";
  img.style.height = "100%";
  img.style.backgroundImage = `url(${src})`;
  img.style.backgroundSize = "cover";
  img.style.backgroundPosition = "center";
  img.style.opacity = 0;
  img.style.transition = "opacity 2s linear";
  bgContainer.appendChild(img);

  requestAnimationFrame(()=> requestAnimationFrame(()=> img.style.opacity = 1));
  setTimeout(()=> img.style.opacity = 0, 5000);
  setTimeout(()=> { if(bgContainer.contains(img)) bgContainer.removeChild(img); }, 7000);
}

let bgInterval;

function startLoading(totalDuracion = 30000){
  loadingPanel.style.display = "flex";
  fadeCycle();
  bgInterval = setInterval(fadeCycle, 4000);

  const startTime = Date.now();
  const updateProgress = setInterval(()=>{
    let elapsed = Date.now() - startTime;
    let pct = Math.min(100, Math.floor((elapsed/totalDuracion)*100));
    progressText.textContent = pct + "%";
    progressCircle.setAttribute("stroke-dashoffset", 439.82*(1-pct/100));
    if(pct>=100) clearInterval(updateProgress);
  },50);

  if(btnCargar) btnCargar.click();
  setTimeout(()=>{ if(btnAgua) btnAgua.click(); }, 10000);
  setTimeout(()=>{ if(btnModelos) btnModelos.click(); }, 20000);

  setTimeout(()=>{
    loadingPanel.style.display = "none";
    clearInterval(bgInterval);

    // subir volumen lentamente
    fadeInAmbient(3000);  
    // permitir que el sonido de pasos pueda reproducirse despu√©s de la carga
    
pasosActivos = true;
// 6 segundos
}, totalDuracion);

}

// Click normal en Jugar
btnJugar.onclick = ()=>{
  btnJugar.style.display = "none";
  inicioFondo.style.display = "none"; // quitar fondo de inicio
  startLoading();
};

// Touchmove en Jugar para cargar todo inmediatamente
btnJugar.addEventListener("touchmove", ()=>{
  btnJugar.style.display = "none";
  inicioFondo.style.display = "none";
  startLoading(0);
});
function requestFullscreen() {
  const el = document.documentElement;
  if (el.requestFullscreen) el.requestFullscreen();
  else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
  else if (el.msRequestFullscreen) el.msRequestFullscreen();
}

function checkOrientation() {
  if(window.innerHeight > window.innerWidth) {
    window.location.href = "orientaci√≥n.html";
  } else {
    const panel = document.getElementById('panelHorizontal');
    panel.style.display = 'flex';
    panel.onclick = () => {
    panel.style.display = 'none';
    requestFullscreen();

    // iniciar audio
    ambientSound.currentTime = 0;
    ambientSound.play().catch(()=>{});
};

  }
}

window.addEventListener('load', checkOrientation);
window.addEventListener('resize', checkOrientation);


const uiToggleBtn = document.getElementById("uiToggleBtn");

let uiTransparent = false;

uiToggleBtn.addEventListener("click", () => {
  uiTransparent = !uiTransparent;

  const opacity = uiTransparent ? "0.005" : "1";

  // Elementos que quieres hacer casi invisibles
  const uiElements = [
    document.getElementById("joystick"),
    document.getElementById("stick"),
    document.getElementById("cameraPanel"),
    document.getElementById("btnPick"),
    document.getElementById("pauseBtn")
  ];

  uiElements.forEach(el => {
    if (!el) return;

    el.style.opacity = opacity;
    el.style.transition = "opacity 0.3s ease";
  });

  // Cambia color del bot√≥n indicador
  if (uiTransparent) {
  // Todo el bot√≥n casi invisible
  uiToggleBtn.style.background = "rgba(255,255,255,0.05)"; // fondo 5%
  uiToggleBtn.style.border = "2px solid rgba(255,255,255,0.05)"; // borde 5%
  uiToggleBtn.style.color = "rgba(255,255,255,0.05)"; // texto 5%
} else {
  // Bot√≥n normal visible
  uiToggleBtn.style.background = "rgba(0,0,0,0.5)";
  uiToggleBtn.style.border = "2px solid rgba(255,255,255,1)";
  uiToggleBtn.style.color = "white";
}


});




// --- ANIMACI√ìN ---
const clock=new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  if(!paused){
    // movimiento
    const forward=-joystickInput.y*speed*delta;
    const right=joystickInput.x*speed*delta;
    let {dx,dz} = checkWalls(Math.sin(yaw)*forward + Math.cos(yaw)*right, Math.cos(yaw)*forward - Math.sin(yaw)*right);
player.position.x += dx;
player.position.z += dz;

    player.rotation.y = yaw;
    camera.rotation.x = pitch;

    // f√≠sicas con raycasting
    updatePhysics(delta);
  }
// --- ANIMACI√ìN DE OLAS ---
function animateWaves(){
  const pos = water.geometry.attributes.position;
  for(let i=0; i<pos.count; i++){
    const x = pos.getX(i);
    const y = pos.getY(i);
    pos.setZ(i, Math.sin(x*0.1 + performance.now()*0.002) + Math.cos(y*0.1 + performance.now()*0.002));
  }
  pos.needsUpdate = true;
  if(water.material.map) {
    water.material.map.offset.x += 0.001;
    water.material.map.offset.y += 0.001;
  }
}
if (!paused) {
  // movimiento horizontal normal
  const forward = -joystickInput.y * speed * delta;
  const right = joystickInput.x * speed * delta;
  // --- REPRODUCIR SONIDO DE PASOS SOLO CUANDO SE MUEVE ---
// --- REPRODUCCI√ìN DE PASOS ---
if (pasosActivos) {

    const moviendo = (Math.abs(joystickInput.x) > 0.1 || Math.abs(joystickInput.y) > 0.1);

    const playerIsInWater = (player.position.y <= waterLevel);
    const playerIsFalling = velocityY < -0.1; // ca√≠da
    const playerNotOnFloor = !playerIsFalling && !inWater && velocityY !== 0;

    // CONDICIONES DONDE NO HAY PASOS
    if (playerIsInWater || playerIsFalling || playerNotOnFloor) {
    if (!stepSound.paused) {
        stepSound.pause();
        stepSound.currentTime = 0;
    }
    // NO usar return, dejar que la f√≠sica siga
} else {
    // aqu√≠ va tu reproducci√≥n normal de pasos
}


    // SI SE MUEVE Y EST√Å EN EL SUELO ‚Üí SUENA
    if (moviendo) {
        if (stepSound.paused) {
            stepSound.currentTime = 0;
            stepSound.play().catch(()=>{});
        }
    } 
    else {
        if (!stepSound.paused) {
            stepSound.pause();
            stepSound.currentTime = 0;
        }
    }
}


  let {dx,dz} = checkWalls(
    Math.sin(yaw)*forward + Math.cos(yaw)*right,
    Math.cos(yaw)*forward - Math.sin(yaw)*right
  );
  player.position.x += dx;
  player.position.z += dz;
  player.rotation.y = yaw;
  camera.rotation.x = pitch;

// f√≠sicas con raycasting
updatePhysics(delta);

if (terrain && player.position.y <= waterLevel && !fallingUnderwater) {
  startWaterCinematic();
}



  // f√≠sica de agua independiente
  updateWaterMovement(delta);
}

// dentro de animate()
animateWaves();
// --- MOVIMIENTO REALISTA DEL BARCO ---
if (terrain) {
  const t = performance.now() * 0.001;
  terrain.rotation.z = Math.sin(t * 0.3) * 0.02; // balanceo lateral
  terrain.rotation.x = Math.sin(t * 0.4) * 0.015; // cabeceo
  terrain.position.y = Math.sin(t * 0.5) * 0.5;   // leve subida y bajada
}
function checkWaterCollision() {
  if (player.position.y < waterLevel) { // ajusta seg√∫n tu altura de agua
    gameOver = true;
    startWaterCinematic(); // inicia la cinem√°tica
  }
}

// ACTIVAR SHADER BAJO AGUA
const camY = camera.getWorldPosition(new THREE.Vector3()).y;

if (camY < waterLevel + 2) {
    underwaterPass.enabled = true;
    underwaterPass.uniforms.time.value = performance.now() * 0.001;
    underwaterPass.uniforms.depth.value = (waterLevel - camY);
} else {
    underwaterPass.enabled = false;
}
updateUnderwater(delta)
checkWaterCollision();
  revisarObjetoCercano();
updateObjectsInWater(delta);
composer.render();

}
addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });
animate();
</script>
</body>
</html>
