<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Supervivencia 3D con jugador</title>
<style>
body { margin: 0; overflow: hidden; background: #000; }
#joystick { position:absolute; bottom:20px; left:20px; width:100px; height:100px; border-radius:50%; background:rgba(0,0,0,0.3); touch-action:none; }
#stick { width:50px; height:50px; background:rgba(0,0,0,0.5); border-radius:50%; position:absolute; left:25px; top:25px; }
#cameraPanel { position:absolute; bottom:20px; right:20px; width:150px; height:150px; background:rgba(0,0,0,0.25); border-radius:10px; touch-action:none; }
#pauseBtn { position:absolute; top:20px; right:20px; padding:10px 15px; font-size:16px; background:rgba(0,0,0,0.5); color:white; border:none; border-radius:8px; z-index:10; }

#pausePanel {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 9;
  background: rgba(0, 0, 0, 0.7);
  font-family: sans-serif;
}

#pauseContent {
  background: linear-gradient(to bottom, #8B5E3C, #A97457); /* madera clara */
  border: 5px solid #5C3A21; /* borde madera oscura */
  border-radius: 12px;
  padding: 15px;
  max-width: 90%;
  max-height: 80%;
  display: flex;
  flex-direction: column;
  align-items: stretch;
  color: #fff;
  box-shadow: 0 0 20px rgba(0,0,0,0.5);
  overflow: hidden;
}

#pauseContent button {
  background: linear-gradient(to bottom, #C27C4F, #A15B32);
  border: 2px solid #5C3A21;
  border-radius: 8px;
  color: white;
  font-size: 18px;
  padding: 10px;
  margin-bottom: 10px;
  cursor: pointer;
}

#pauseContent button:hover {
  background: linear-gradient(to bottom, #D08F5C, #B26940);
}

#settingsPanel {
  flex: 1;
  overflow: hidden;
  margin-top: 10px;
}

#settingsScroll {
  overflow-y: auto;
  -webkit-overflow-scrolling: touch; /* scroll suave en m칩viles */
  display: flex;
  flex-direction: column;
  gap: 10px;
  padding-right: 5px;
  max-height: 100%;
}

#settingsScroll label, #settingsScroll fieldset {
  display: flex;
  flex-direction: column;
  font-size: 14px;
  color: #fff;
}

#settingsScroll input[type="range"] {
  margin-top: 5px;
}

#settingsScroll fieldset {
  border: 2px solid #5C3A21;
  border-radius: 8px;
  padding: 10px;
}

#settingsScroll legend {
  padding: 0 5px;
  color: #fff;
  font-weight: bold;
}

#postProcessLabel {
  display: flex;
  align-items: center;
  gap: 5px;
  font-weight: bold;
}






</style>

</style>
</head>
<body>

<div id="joystick"><div id="stick"></div></div>
<div id="cameraPanel"></div>
<button id="pauseBtn">Pausa</button>

<div id="pausePanel">
  <div id="pauseContent">
    <button id="resumeBtn">Reanudar</button>
    <button id="settingsBtn">Ajustes</button>

    <div id="settingsPanel">
      <div id="settingsScroll">
        <label>
  Sensibilidad de c치mara:
  <input type="range" id="cameraSensitivity" min="0.0005" max="0.01" step="0.0001" value="0.0025">
  <span id="cameraSensitivityValue">0.0025</span>
</label>

        <label>
          Distancia de renderizado:
          <input type="range" id="renderDist" min="20" max="500" value="100">
          <span id="renderDistValue">100</span>
        </label>

        <label>
          <input type="checkbox" id="fogToggle" checked>
          Activar niebla
        </label>

        <label>
          <input type="checkbox" id="transparentToggle">
          Activar texturas transparentes
        </label>

        <label>
          Calidad (Pixel Ratio):
          <input type="range" id="pixelRatioSlider" min="0.25" max="2" step="0.05" value="0.75">
          <span id="pixelRatioValue">0.75</span>
        </label>

        <fieldset id="filmControls">
          <legend>FilmPass (Pel칤cula)</legend>
          <label>Intensidad del ruido: <input type="range" id="filmNoise" min="0" max="0.5" step="0.005" value="0"><span id="filmNoiseVal">0</span></label>
          <label>Intensidad de l칤neas de escaneo: <input type="range" id="filmScanline" min="0" max="0.5" step="0.005" value="0"><span id="filmScanlineVal">0</span></label>
          <label>Escala de grises: <input type="checkbox" id="filmGray" checked></label>
        </fieldset>

        <fieldset id="bokehControls">
          <legend>BokehPass (Profundidad de campo)</legend>
          <label>Enfoque (Focus): <input type="range" id="bokehFocus" min="1" max="50" step="0.5" value="50"><span id="bokehFocusVal">50</span></label>
          <label>Apertura: <input type="range" id="bokehAperture" min="0.00001" max="0.001" step="0.00001" value="0.00021"><span id="bokehApertureVal">0.00021</span></label>
          <label>Desenfoque m치ximo: <input type="range" id="bokehMaxBlur" min="0.001" max="0.02" step="0.001" value="0.02"><span id="bokehMaxBlurVal">0.02</span></label>
        </fieldset>

        <label id="postProcessLabel">
          <input type="checkbox" id="postProcessToggle" checked>
          Activar postprocesado
        </label>
      </div>
    </div>
  </div>
</div>


<script type="module">
import * as THREE from "https://esm.sh/three@0.162.0";
import { GLTFLoader } from "https://esm.sh/three@0.162.0/examples/jsm/loaders/GLTFLoader.js";
import { EffectComposer } from "https://esm.sh/three@0.162.0/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://esm.sh/three@0.162.0/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "https://esm.sh/three@0.162.0/examples/jsm/postprocessing/UnrealBloomPass.js";
import { FilmPass } from "https://esm.sh/three@0.162.0/examples/jsm/postprocessing/FilmPass.js";
import { BokehPass } from "https://esm.sh/three@0.162.0/examples/jsm/postprocessing/BokehPass.js";

// --- ESCENA ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.Fog(0x87ceeb, 20, 100);

// --- RAYCASTER GLOBAL ---
const raycaster = new THREE.Raycaster();

// --- RENDERER ---
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);
// --- CIELO 360 JPG ---
const textureLoader = new THREE.TextureLoader();
textureLoader.load("models/cielo.jpg", (texture) => {
  texture.mapping = THREE.EquirectangularReflectionMapping;
  scene.background = texture;
  
});

// --- PLAYER ---
const player = new THREE.Object3D();
scene.add(player);
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 200);
camera.position.set(0,10,0);
player.add(camera);
const composer = new EffectComposer(renderer);
const renderPass = new RenderPass(scene, camera);
composer.addPass(renderPass);
const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(innerWidth, innerHeight),
  0.5, // intensidad
  0.5, // radio
  0.2  // umbral
);
composer.addPass(bloomPass);
const filmPass = new FilmPass(0.01, 0.05, 648, false);
composer.addPass(filmPass);
const bokeh = new BokehPass(scene, camera, {
  focus: 10,       // distancia n칤tida
  aperture: 0.00021,// intensidad de desenfoque
  maxblur: 0.02   // m치ximo desenfoque
});
composer.addPass(bokeh);

// --- CUBO DE COLISI칍N ---
const playerCollider = new THREE.Mesh(
  new THREE.BoxGeometry(1,2,1),
  new THREE.MeshBasicMaterial({visible:false})
);
player.add(playerCollider);

// --- LUCES ---
const sun = new THREE.DirectionalLight(0xffd080, 2);
sun.position.set(50,100,50);
scene.add(sun);
scene.add(new THREE.AmbientLight(0xffffff, 0.4));

// --- TERRAIN BARCO ---
const loader = new GLTFLoader();
let terrain = null;
loader.load("models/Barco.gltf", gltf=>{
  terrain = gltf.scene;
  terrain.scale.set(10,10,10); 
  scene.add(terrain);

  // colocar jugador encima del modelo
  player.position.set(50,100,0);
});
// --- SLIDER PIXEL RATIO ---
const pixelRatioSlider = document.getElementById('pixelRatioSlider');
const pixelRatioValue = document.getElementById('pixelRatioValue');

pixelRatioSlider.addEventListener('input', () => {
  const ratio = parseFloat(pixelRatioSlider.value);
  pixelRatioValue.textContent = ratio.toFixed(2);
  renderer.setPixelRatio(window.devicePixelRatio * ratio);
});
const filmNoiseSlider = document.getElementById('filmNoise');
const filmNoiseVal = document.getElementById('filmNoiseVal');
filmNoiseSlider.addEventListener('input', ()=>{
  filmPass.uniforms['nIntensity'].value = parseFloat(filmNoiseSlider.value);
  filmNoiseVal.textContent = parseFloat(filmNoiseSlider.value).toFixed(3);
});

const filmScanlineSlider = document.getElementById('filmScanline');
const filmScanlineVal = document.getElementById('filmScanlineVal');
filmScanlineSlider.addEventListener('input', ()=>{
  filmPass.uniforms['sIntensity'].value = parseFloat(filmScanlineSlider.value);
  filmScanlineVal.textContent = parseFloat(filmScanlineSlider.value).toFixed(3);
});

const filmGrayCheckbox = document.getElementById('filmGray');
filmGrayCheckbox.addEventListener('change', ()=>{
  filmPass.uniforms['grayscale'].value = filmGrayCheckbox.checked ? 1 : 0;
});
const bokehFocusSlider = document.getElementById('bokehFocus');
const bokehFocusVal = document.getElementById('bokehFocusVal');
bokehFocusSlider.addEventListener('input', ()=>{
  bokeh.materialBokeh.uniforms['focus'].value = parseFloat(bokehFocusSlider.value);
  bokehFocusVal.textContent = parseFloat(bokehFocusSlider.value).toFixed(1);
});

const bokehApertureSlider = document.getElementById('bokehAperture');
const bokehApertureVal = document.getElementById('bokehApertureVal');
bokehApertureSlider.addEventListener('input', ()=>{
  bokeh.materialBokeh.uniforms['aperture'].value = parseFloat(bokehApertureSlider.value);
  bokehApertureVal.textContent = parseFloat(bokehApertureSlider.value).toFixed(5);
});

const bokehMaxBlurSlider = document.getElementById('bokehMaxBlur');
const bokehMaxBlurVal = document.getElementById('bokehMaxBlurVal');
bokehMaxBlurSlider.addEventListener('input', ()=>{
  bokeh.materialBokeh.uniforms['maxblur'].value = parseFloat(bokehMaxBlurSlider.value);
  bokehMaxBlurVal.textContent = parseFloat(bokehMaxBlurSlider.value).toFixed(3);
});
const postProcessToggle = document.getElementById('postProcessToggle');

postProcessToggle.addEventListener('change', () => {
  const enabled = postProcessToggle.checked;
  // Solo deshabilitamos los pases, no el composer
  composer.passes.forEach(pass => {
    if (pass !== composer.passes[0]) { // opcional: si el primer pase es renderPass base, lo dejamos activo
      pass.enabled = enabled;
    }
  });
});
const cameraSensitivitySlider = document.getElementById('cameraSensitivity');
const cameraSensitivityValue = document.getElementById('cameraSensitivityValue');
let lookSensitivity = 0.0025; // valor por defecto

cameraSensitivitySlider.addEventListener('input', ()=>{
  lookSensitivity = parseFloat(cameraSensitivitySlider.value);
  cameraSensitivityValue.textContent = lookSensitivity.toFixed(4);
});

// --- MOVIMIENTO FPS ---
let yaw=0, pitch=0, joystickInput={x:0,y:0}, speed=10;
const joystick=document.getElementById('joystick');
const stick=document.getElementById('stick');
let joystickId=null, startX=0, startY=0;

joystick.addEventListener('touchstart', e=>{
  for(const t of e.changedTouches){
    if(joystickId===null){ joystickId=t.identifier; startX=t.clientX; startY=t.clientY; break; }
  }
});
joystick.addEventListener('touchmove', e=>{
  if(joystickId===null) return;
  for(const t of e.changedTouches){
    if(t.identifier===joystickId){
      const dx=t.clientX-startX, dy=t.clientY-startY;
      const maxDist=40;
      const moveX=Math.max(-maxDist,Math.min(maxDist,dx));
      const moveY=Math.max(-maxDist,Math.min(maxDist,dy));
      stick.style.transform=`translate(${moveX}px,${moveY}px)`;
      joystickInput.x=moveX/maxDist; joystickInput.y=-moveY/maxDist; break;
    }
  }
});
joystick.addEventListener('touchend', e=>{
  for(const t of e.changedTouches){
    if(t.identifier===joystickId){ stick.style.transform='translate(0,0)'; joystickInput.x=0; joystickInput.y=0; joystickId=null; break; }
  }
});

// --- TRANSPARENCIA ---
const transparentToggle = document.getElementById('transparentToggle');
transparentToggle.addEventListener('change', ()=>{
  if(!terrain) return;
  const enable = transparentToggle.checked;
  terrain.traverse(n=>{
    if(n.isMesh && n.material.map){
      n.material.transparent = enable;
      n.material.needsUpdate = true;
    }
  });
});

// --- PANEL CAMARA ---
const cameraPanel=document.getElementById('cameraPanel');
let lookId=null, lookStartX=0, lookStartY=0;
cameraPanel.addEventListener('touchstart', e=>{
  for(const t of e.changedTouches){
    if(lookId===null){ lookId=t.identifier; lookStartX=t.clientX; lookStartY=t.clientY; break; }
  }
});
cameraPanel.addEventListener('touchmove', e=>{
  if(lookId===null) return;
  for(const t of e.changedTouches){
    if(t.identifier===lookId){
      const dx=t.clientX-lookStartX, dy=t.clientY-lookStartY;
      yaw -= dx * lookSensitivity;
      pitch -= dy * lookSensitivity;
      pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
      lookStartX = t.clientX;
      lookStartY = t.clientY;
      break;
    }
  }
});

cameraPanel.addEventListener('touchend', e=>{ for(const t of e.changedTouches){ if(t.identifier===lookId) lookId=null; } });

// --- PAUSA / AJUSTES ---
const pauseBtn=document.getElementById('pauseBtn');
const pausePanel=document.getElementById('pausePanel');
const resumeBtn=document.getElementById('resumeBtn');
const settingsBtn=document.getElementById('settingsBtn');
const settingsPanel=document.getElementById('settingsPanel');
const renderDistInput=document.getElementById('renderDist');
const renderDistValue=document.getElementById('renderDistValue');
const fogToggle=document.getElementById('fogToggle');
let paused=false;

pauseBtn.addEventListener('click', ()=>{ paused=true; pausePanel.style.display='flex'; });
resumeBtn.addEventListener('click', ()=>{ paused=false; pausePanel.style.display='none'; settingsPanel.style.display='none'; });
settingsBtn.addEventListener('click', ()=>{ settingsPanel.style.display=(settingsPanel.style.display==='flex')?'none':'flex'; });
renderDistInput.addEventListener('input', ()=>{
  const val=parseFloat(renderDistInput.value);
  camera.far=val; camera.updateProjectionMatrix();
  scene.fog.far=val; scene.fog.near=val/5;
  renderDistValue.textContent=val;
});
fogToggle.addEventListener('change', ()=>{ scene.fog = fogToggle.checked ? new THREE.Fog(0x87ceeb, camera.far/5, camera.far) : null; });

// --- RAYCASTING Y F칈SICAS ---
const down = new THREE.Vector3(0,-1,0);
let velocityY = 0;
function updatePhysics(delta){
  if(!terrain) return;
  // raycasting desde el cubo de colisi칩n
  raycaster.set(playerCollider.getWorldPosition(new THREE.Vector3()).add(new THREE.Vector3(0,5,0)), down);
  const intersects = raycaster.intersectObject(terrain,true);
  if(intersects.length>0){
    const groundY = intersects[0].point.y + 1; // altura sobre el modelo
    if(player.position.y > groundY){
      velocityY -= 9.8 * delta; // gravedad
      player.position.y += velocityY * delta;
      if(player.position.y < groundY){
        player.position.y = groundY;
        velocityY = 0;
      }
    } else {
      velocityY = 0;
      player.position.y = groundY;
    }
  }
}
// --- Detectar colisiones horizontales ---
function checkWalls(deltaX, deltaZ) {
  if (!terrain) return { dx: deltaX, dz: deltaZ };

  const directions = [
    new THREE.Vector3(deltaX, 0, 0),
    new THREE.Vector3(0, 0, deltaZ)
  ];
  let dx = deltaX, dz = deltaZ;

  directions.forEach((dir) => {
    const origin = playerCollider.getWorldPosition(new THREE.Vector3());
    origin.y += 1; // 游댳 eleva el rayo al centro del jugador (ajusta seg칰n tu altura)
    raycaster.set(origin, dir.clone().normalize());
    const intersects = raycaster.intersectObject(terrain, true);
    if (intersects.length > 0 && intersects[0].distance < 0.8) { // menor distancia = m치s preciso
      if (dir.x !== 0) dx = 0;
      if (dir.z !== 0) dz = 0;
    }
  });

  return { dx, dz };
}

const maxStepHeight = 1.0; // altura m치xima que puede subir

function updatePlayerHeight(){
  if(terrain){
    raycaster.set(player.position.clone().add(new THREE.Vector3(0,10,0)), down);
    const intersects = raycaster.intersectObject(terrain, true);
    if(intersects.length>0){
      const targetY = intersects[0].point.y + playerHeightOffset;
      // permitir subir solo si diferencia < maxStepHeight
      if(targetY - player.position.y <= maxStepHeight){
        player.position.y = targetY;
      }
    }
  }
}
// --- AGUA ANIMADA CON TEXTURA ---

const waterGeo = new THREE.PlaneGeometry(500, 500, 100, 100);
const waterMat = new THREE.MeshPhongMaterial({
  color: 0x1e90ff,
  side: THREE.DoubleSide,
  transparent: true,
  opacity: 0.8
});
const water = new THREE.Mesh(waterGeo, waterMat);
water.rotation.x = -Math.PI/2;
water.position.y = 0;
scene.add(water);

// cargar textura
textureLoader.load('models/agua.jpg', (texture)=>{
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(10,10);
  water.material.map = texture;
  water.material.needsUpdate = true;
});

// --- Par치metros del agua ---
const waterLevel = 0;        // altura de la superficie del agua
let inWater = false;         // si el jugador est치 en el agua
let swimSpeed = 5;           // velocidad horizontal en el agua
let buoyancy = 15;           // fuerza de flotaci칩n
let swimUpVelocity = 0;      // velocidad vertical en el agua

function updateWaterMovement(delta) {
  if (!terrain) return;
  const playerPos = player.position.clone();

  // Raycast hacia abajo para detectar suelo
  const origin = playerCollider.getWorldPosition(new THREE.Vector3()).add(new THREE.Vector3(0,1,0));
  raycaster.set(origin, new THREE.Vector3(0,-1,0));
  const intersects = raycaster.intersectObject(terrain, true);

  // Determinar si el jugador debe caer o entrar al agua
  if (intersects.length > 0) {
    const groundY = intersects[0].point.y + 1;
    if (playerPos.y > groundY) {
      if (!inWater) velocityY -= 9.8 * delta; // gravedad normal
      player.position.y += velocityY * delta;
      if (player.position.y < groundY) {
        player.position.y = groundY;
        velocityY = 0;
      }
    }
  } else {
    // sin suelo, caer hasta llegar al agua
    if (playerPos.y > waterLevel) {
      velocityY -= 9.8 * delta;
      player.position.y += velocityY * delta;
      if (player.position.y <= waterLevel) {
        player.position.y = waterLevel;
        inWater = true;
        swimUpVelocity = 0;
        velocityY = 0;
      }
    } else {
      inWater = true; // jugador ya en agua
    }
  }

  // --- F칤sica de agua ---
  if (inWater) {
    const depth = waterLevel - player.position.y;
    swimUpVelocity += buoyancy * delta * Math.min(depth, 1);
    if (swimUpVelocity > 10) swimUpVelocity = 10;
    player.position.y += swimUpVelocity * delta;

    // movimiento en la direcci칩n de la c치mara
    const moveX = -Math.sin(yaw) * joystickInput.y + Math.cos(yaw) * joystickInput.x;
    const moveZ = -Math.cos(yaw) * joystickInput.y - Math.sin(yaw) * joystickInput.x;
    player.position.x += moveX * swimSpeed * delta;
    player.position.z += moveZ * swimSpeed * delta;

    // salir del agua si toca superficie
    if (player.position.y >= waterLevel) {
      inWater = false;
      swimUpVelocity = 0;
    }
  }
}

// --- ANIMACI칍N ---
const clock=new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  if(!paused){
    // movimiento
    const forward=-joystickInput.y*speed*delta;
    const right=joystickInput.x*speed*delta;
    let {dx,dz} = checkWalls(Math.sin(yaw)*forward + Math.cos(yaw)*right, Math.cos(yaw)*forward - Math.sin(yaw)*right);
player.position.x += dx;
player.position.z += dz;

    player.rotation.y = yaw;
    camera.rotation.x = pitch;

    // f칤sicas con raycasting
    updatePhysics(delta);
  }
// --- ANIMACI칍N DE OLAS ---
function animateWaves(){
  const pos = water.geometry.attributes.position;
  for(let i=0; i<pos.count; i++){
    const x = pos.getX(i);
    const y = pos.getY(i);
    pos.setZ(i, Math.sin(x*0.1 + performance.now()*0.002) + Math.cos(y*0.1 + performance.now()*0.002));
  }
  pos.needsUpdate = true;
  if(water.material.map) {
    water.material.map.offset.x += 0.001;
    water.material.map.offset.y += 0.001;
  }
}
if (!paused) {
  // movimiento horizontal normal
  const forward = -joystickInput.y * speed * delta;
  const right = joystickInput.x * speed * delta;
  let {dx,dz} = checkWalls(
    Math.sin(yaw)*forward + Math.cos(yaw)*right,
    Math.cos(yaw)*forward - Math.sin(yaw)*right
  );
  player.position.x += dx;
  player.position.z += dz;
  player.rotation.y = yaw;
  camera.rotation.x = pitch;

  // f칤sicas normales
  updatePhysics(delta);

  // f칤sica de agua independiente
  updateWaterMovement(delta);
}

// dentro de animate()
animateWaves();
// --- MOVIMIENTO REALISTA DEL BARCO ---
if (terrain) {
  const t = performance.now() * 0.001;
  terrain.rotation.z = Math.sin(t * 0.3) * 0.02; // balanceo lateral
  terrain.rotation.x = Math.sin(t * 0.4) * 0.015; // cabeceo
  terrain.position.y = Math.sin(t * 0.5) * 0.5;   // leve subida y bajada
}


composer.render();

}
addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });
animate();
</script>
</body>
</html>
